<!DOCTYPE html>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<html>
  <head>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
    <link rel="stylesheet" href="css/bootstrap.min.css">
    <link rel="stylesheet" href="css/style.css">
    <script type="text/javascript"
      src="js/vendor/jquery.js">
    </script>
    <script type="text/javascript"
            src="js/vendor/annyang.min.js">
    </script>
    <script type="text/javascript"
      src="js/vendor/lodash.compat.min.js">
    </script>
    <script type="text/javascript"
      src="js/eventing/eventing.js">
    </script>
    <script type="text/javascript"
      src="js/eventing/porthole.js">
    </script>
    <script type="text/javascript"
      src="https://maps.googleapis.com/maps/api/js?key=<%= map_key %>&sensor=true" >
    </script>
    <script type="text/javascript"
      src="js/map/umap.js">
    </script>
    <script type="text/javascript"
      src="js/map/googlev3/google_v3.js">
    </script>
    <script type="text/javascript"
      src="js/map/googlev3/overlay.js">
    </script>
    <script type="text/javascript"
      src="js/map/googlev3/KmlFeature.js">
    </script>
    <script type="text/javascript"
      src="js/map/googlev3/GeoJsonFeature.js">
    </script>
    <script type="text/javascript"
      src="js/vendor/geojson.min.js">
    </script>
    <script type="text/javascript"
      src="js/vendor/socket.io.min.js">
    </script>
    <script type="text/javascript"
      src="js/eventing/relay.js">
    </script>
    <script type="text/javascript"
      src="js/map/roomManager.js">
    </script>
  </head>

  <body>
    <div id="room-manager" class="room-manager">
      <div id="room-manager-tab">
        <h4><a>Room Manager</a></h4>
        <span class="glyphicon glyphicon-chevron-down" id="room-manager-icon"></span>
      </div>
      <div id="room-manager-menu" class="room-manager-menu">
        <div class="row">
          <div class="col-sm-4 room-manager-menu-col-1">
            <form class="room-manager-selector">
              <input type="text" id="roomName" name="roomName" class="input" placeholder="New room name">
              <button type="button" id="roomNameSubmit" class="btn glyphicon glyphicon-ok" alt="Submit"></button>
            </form>
            <form class="room-manager-selector">
              <input type="text" id="userName" name="userName" class="input" placeholder="User name">
              <button type="button" id="userNameSubmit" class="btn glyphicon glyphicon-ok" alt="Submit"></button>
            </form>
          </div>
          <div class="col-sm-4 room-manager-menu-col-2">
            <h5>Rooms</h5>
            <ul class="list-unstyled" id="room-list"></ul>
          </div>
          <div class="col-sm-4 room-manager-menu-col-3">
            <h5>Users</h5>
            <ul class="list-unstyled" id="room-users"></ul>
          </div>
        </div>
      </div>
  </div>
    <div id="map-canvas" class="map-canvas"></div>
    <script>
      $(document).ready(function () {
        // Create a proxy window to send to and receive
        // messages from the iFrame
        //new uMap('googlev3', 'map-canvas');
        var map;

        umap.Eventing.init('/proxy.html');
        if (_(window.loadRelay).isFunction()) {
          $(window).bind('socketConnected', function () {
            map = new uMap('googlev3', 'map-canvas');
          });
        } else {
          $(window).bind('eventingReady', function () {
            map = new uMap('googlev3', 'map-canvas');
          });
        }
        var markers = {};
        var geocoder = new google.maps.Geocoder();

        function markLocation(address) {
          window.parent.dialogBox('mark ' + address);
          changeMap(address, function (results, status) {
            map.map.setCenter(results[0].geometry.location);

            var marker = new google.maps.Marker({
              map: map.map,
              position: results[0].geometry.location
            });

            markers[address] = marker;
          });
        }

        function moveToLocation(address) {
          window.parent.dialogBox('move to ' + address);
          changeMap(address, function (results) {
            map.map.setCenter(results[0].geometry.location);
          });
        }

        function removeMarker(address) {
          window.parent.dialogBox('remove marker ' + address);
          var marker = markers[address];
          if (marker) {
            marker.setMap(null);
            delete markers[address];
          }
        }

        function removeAllMarkers(){
          window.parent.dialogBox('remove all markers');
          for(var key in markers){
            if(markers.hasOwnProperty(key)){
              removeMarker(key);
            }
          }
        }

        function removeMarkerEstimate(address) {
          window.parent.dialogBox('remove marker ' + address);
          var max = 0;
          var maxKey = '';
          for (var key in markers) {

            var levenDist = getEditDistance(key, address);
            var maxString = Math.max(address.length, key.length);
            var ratio = (maxString - levenDist) / maxString;
            if (max < ratio) {
              max = ratio;
              maxKey = key;
            }
          }
          if (max > .75) {
            removeMarker(maxKey);
          }
          else {
            window.parent.dialogBox("best match " + max);
          }
        }

        function changeMap(address, callback) {
          geocoder.geocode({'address': address}, function (results, status) {
            if (status == google.maps.GeocoderStatus.OK) {
              callback(results);
            }
          });
        }

        function otherCommands(term) {
          window.parent.dialogBox(term);
        }

        function zoom(level) {
          map.map.setZoom(level);
        }

        function levenshteinDistance(s, t) {
          if (s.length === 0) return t.length;
          if (t.length === 0) return s.length;

          s = s.toLowerCase();
          t = t.toLowerCase();

          return Math.min(
                  levenshteinDistance(s.substr(1), t) + 1,
                  levenshteinDistance(t.substr(1), s) + 1,
                  levenshteinDistance(s.substr(1), t.substr(1)) + (s[0] !== t[0] ? 1 : 0)
          );
        }

        // Compute the edit distance between the two given strings
        function getEditDistance(a, b) {
          if (a.length === 0) return b.length;
          if (b.length === 0) return a.length;

          var matrix = [];

          // increment along the first column of each row
          var i;
          for (i = 0; i <= b.length; i++) {
            matrix[i] = [i];
          }

          // increment each column in the first row
          var j;
          for (j = 0; j <= a.length; j++) {
            matrix[0][j] = j;
          }

          // Fill in the rest of the matrix
          for (i = 1; i <= b.length; i++) {
            for (j = 1; j <= a.length; j++) {
              if (b.charAt(i - 1) == a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
              } else {
                matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, // substitution
                        Math.min(matrix[i][j - 1] + 1, // insertion
                                matrix[i - 1][j] + 1)); // deletion
              }
            }
          }

          return matrix[b.length][a.length];
        };

        var commands = {
          '(place) marker (at) *location': markLocation,
          'move to *location': moveToLocation,
          'remove marker (at) *location': removeMarkerEstimate,
          'remove all markers': removeAllMarkers,
          'zoom number :level': zoom,
          '(show) CIA (data) (about) *stuff': showDataCIA,
          '(show) air force (data) (about) *stuff': showDataAIRFORCE,
          '(show) FBI (data) (about) *stuff': showDataFBI,
          '*term': otherCommands
        };

        annyang.addCommands(commands);

        annyang.start();
        console.log("annyang started");

        // FBI
        var FBI_DATA = [
          ['attack source 1', 39.043005, 125.742541, 1],
          ['attack source 2', 39.045805, 125.740481, 2],
          ['attack source 3', 39.045593, 125.740315, 3],
          ['attack source 4', 39.045934, 125.739821, 4],
          ['attack source 5', 39.045842, 125.741066, 5]
        ]

        // NSA DATA
        var AIRFORCE_DATA = [
          ['International Sony server 1', 35.631735, 139.749537, 7],
          ['International Sony server 2', 35.617315, 139.728413, 8],
          ['International Sony server 3', 35.623279, 139.733165, 9],
          ['International Sony server 4', 35.630211, 139.789543, 10],
          ['International Sony server 5', 35.433308, 139.369281, 11],
          ['International Sony server 6', 35.428339, 139.370340, 12],
          ['International Sony server 7', 38.287285, 141.015859, 13]
        ]

        // CIA
        var CIA_DATA = [
          ['US Sony servers', 34.017644, -118.401340, 6]
        ]

        // scenario goes CIA -> NSA -> FBI

        function setMarkers(map, locations) {
            // Add markers to the map

            // Marker sizes are expressed as a Size of X,Y
            // where the origin of the image (0,0) is located
            // in the top left of the image.

            // Origins, anchor positions and coordinates of the marker
            // increase in the X direction to the right and in
            // the Y direction down.
            var image = {
              url: 'images/red-skull-and-bones.jpg',
              // This marker is 20 pixels wide by 32 pixels tall.
              size: new google.maps.Size(121, 122),
              // The origin for this image is 0,0.
              origin: new google.maps.Point(0,0),
              // The anchor for this image is the base of the flagpole at 0,32.
              anchor: new google.maps.Point(0, 32)
            };
            // Shapes define the clickable region of the icon.
            // The type defines an HTML &lt;area&gt; element 'poly' which
            // traces out a polygon as a series of X,Y points. The final
            // coordinate closes the poly by connecting to the first
            // coordinate.
            var shape = {
                coords: [1, 1, 1, 20, 18, 20, 18 , 1],
                type: 'poly'
            };
            for (var i = 0; i < locations.length; i++) {
              var beach = locations[i];
              var markerName = beach[0];
              var myLatLng = new google.maps.LatLng(beach[1], beach[2]);
              var marker = new google.maps.Marker({
                  position: myLatLng,
                  map: map,
                  icon: image,
                  shape: shape,
                  title: markerName,
                  zIndex: beach[3]
              });
              markers[markerName] = marker;
            }
          }

          function showDataCIA () {
            setMarkers(map.map, CIA_DATA);
          }

          function showDataFBI () {
            setMarkers(map.map, FBI_DATA);
          }

          function showDataAIRFORCE () {
            setMarkers(map.map, AIRFORCE_DATA);
          }

      });
    </script>
  </body>
</html>
